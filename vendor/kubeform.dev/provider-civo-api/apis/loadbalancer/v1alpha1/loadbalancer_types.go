/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	base "kubeform.dev/apimachinery/api/v1alpha1"

	core "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	kmapi "kmodules.xyz/client-go/api/v1"
	"sigs.k8s.io/cli-utils/pkg/kstatus/status"
)

// +genclient
// +k8s:openapi-gen=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`

type Loadbalancer struct {
	metav1.TypeMeta   `json:",inline,omitempty"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              LoadbalancerSpec   `json:"spec,omitempty"`
	Status            LoadbalancerStatus `json:"status,omitempty"`
}

type LoadbalancerSpecBackend struct {
	InstanceID *string `json:"instanceID" tf:"instance_id"`
	Port       *int64  `json:"port" tf:"port"`
	Protocol   *string `json:"protocol" tf:"protocol"`
}

type LoadbalancerSpec struct {
	State *LoadbalancerSpecResource `json:"state,omitempty" tf:"-"`

	Resource LoadbalancerSpecResource `json:"resource" tf:"resource"`

	UpdatePolicy base.UpdatePolicy `json:"updatePolicy,omitempty" tf:"-"`

	TerminationPolicy base.TerminationPolicy `json:"terminationPolicy,omitempty" tf:"-"`

	ProviderRef core.LocalObjectReference `json:"providerRef" tf:"-"`
}

type LoadbalancerSpecResource struct {
	ID string `json:"id,omitempty" tf:"id,omitempty"`

	// a list of backend instances, each containing an instance_id, protocol (http or https) and port
	Backend []LoadbalancerSpecBackend `json:"backend" tf:"backend"`
	// how long to wait in seconds before determining a backend has failed, defaults to 30
	FailTimeout *int64 `json:"failTimeout" tf:"fail_timeout"`
	// what URL should be used on the backends to determine if it's OK (2xx/3xx status), defaults to /
	// +optional
	HealthCheckPath *string `json:"healthCheckPath,omitempty" tf:"health_check_path"`
	// the hostname to receive traffic for, e.g. www.example.com (optional: sets hostname to loadbalancer-uuid.civo.com if blank)
	Hostname *string `json:"hostname" tf:"hostname"`
	// should self-signed/invalid certificates be ignored from the backend servers, defaults to true
	// +optional
	IgnoreInvalidBackendTls *bool `json:"ignoreInvalidBackendTls,omitempty" tf:"ignore_invalid_backend_tls"`
	// how many concurrent connections can each backend handle, defaults to 10
	MaxConns *int64 `json:"maxConns" tf:"max_conns"`
	// the size in megabytes of the maximum request content that will be accepted, defaults to 20
	MaxRequestSize *int64 `json:"maxRequestSize" tf:"max_request_size"`
	// one of: least_conn (sends new requests to the least busy server), random (sends new requests to a random backend), round_robin (sends new requests to the next backend in order), ip_hash (sends requests from a given IP address to the same backend), default is random
	Policy *string `json:"policy" tf:"policy"`
	// you can listen on any port, the default is 80 to match the default protocol of http,if not you must specify it here (commonly 80 for HTTP or 443 for HTTPS)
	Port *int64 `json:"port" tf:"port"`
	// either http or https. If you specify https then you must also provide the next two fields, the default is http
	Protocol *string `json:"protocol" tf:"protocol"`
	// if your protocol is https then you should send the TLS certificate in Base64-encoded PEM format
	// +optional
	TlsCertificate *string `json:"tlsCertificate,omitempty" tf:"tls_certificate"`
	// if your protocol is https then you should send the TLS private key in Base64-encoded PEM format
	// +optional
	TlsKey *string `json:"tlsKey,omitempty" tf:"tls_key"`
}

type LoadbalancerStatus struct {
	// Resource generation, which is updated on mutation by the API Server.
	// +optional
	ObservedGeneration int64 `json:"observedGeneration,omitempty"`
	// +optional
	Phase status.Status `json:"phase,omitempty"`
	// +optional
	Conditions []kmapi.Condition `json:"conditions,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true

// LoadbalancerList is a list of Loadbalancers
type LoadbalancerList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	// Items is a list of Loadbalancer CRD objects
	Items []Loadbalancer `json:"items,omitempty"`
}
